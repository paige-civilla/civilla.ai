# Slice 4B (A): Court DOCX “pleading-perfect” formatting (margins, caption block, double spacing, page numbers)
# Paste this into Replit Shell.

set -e

mkdir -p server

cat > server/courtDocx.ts <<'EOF'
import {
  AlignmentType,
  BorderStyle,
  Document,
  Footer,
  Header,
  HeadingLevel,
  Packer,
  PageNumber,
  Paragraph,
  SectionType,
  Table,
  TableCell,
  TableRow,
  TextRun,
  WidthType,
} from "docx";

export type CourtDocxPayload = {
  court: { district?: string; county?: string; state?: string };
  case: { caseNumber?: string };
  parties: { petitioner?: string; respondent?: string };
  filer: {
    fullName?: string;
    email?: string;
    addressLine1?: string;
    addressLine2?: string;
    city?: string;
    state?: string;
    zip?: string;
    phone?: string;
    partyRole?: string;
    isSelfRepresented?: boolean;
    attorney?: {
      name?: string;
      firm?: string;
      barNumber?: string;
      email?: string;
      phone?: string;
      address?: string;
    };
  };
  document?: { title?: string; subtitle?: string };
  date?: string;
  body?: string[]; // paragraphs
};

const FONT = "Times New Roman";
const FONT_SIZE = 24; // docx uses half-points (24 = 12pt)
const DOUBLE_LINE = 480; // twips; 240=single, 480=double
const PARA_AFTER = 0; // court docs typically avoid extra spacing when double-spaced
const ONE_INCH = 1440; // twips

function tr(text: string, opts?: { bold?: boolean; italics?: boolean }) {
  return new TextRun({
    text,
    bold: !!opts?.bold,
    italics: !!opts?.italics,
    font: FONT,
    size: FONT_SIZE,
  });
}

function p(text?: string, opts?: { align?: AlignmentType; bold?: boolean; italics?: boolean; keepNext?: boolean }) {
  return new Paragraph({
    children: text ? [tr(text, { bold: opts?.bold, italics: opts?.italics })] : [],
    alignment: opts?.align ?? AlignmentType.LEFT,
    spacing: { line: DOUBLE_LINE, after: PARA_AFTER },
    keepNext: opts?.keepNext ?? false,
  });
}

function blank(lines = 1) {
  // Add blank double-spaced lines reliably
  return Array.from({ length: lines }).map(() => p(" "));
}

function safeJoin(parts: Array<string | undefined | null>, sep = " ") {
  return parts.filter(Boolean).join(sep).trim();
}

function captionTable(payload: CourtDocxPayload) {
  const petitioner = payload.parties?.petitioner || "Petitioner";
  const respondent = payload.parties?.respondent || "Respondent";
  const caseNo = payload.case?.caseNumber || "__________";
  const courtState = payload.court?.state || "Idaho";
  const courtCounty = payload.court?.county || "__________";
  const district = payload.court?.district || "__________";

  // Left side (party block)
  const leftLines: Paragraph[] = [
    p(petitioner),
    p("Petitioner,"),
    p("v."),
    p(respondent),
    p("Respondent."),
  ];

  // Right side (case block)
  const rightLines: Paragraph[] = [
    p(`IN THE DISTRICT COURT OF THE ${district} JUDICIAL DISTRICT`),
    p(`OF THE STATE OF ${courtState.toUpperCase()}, IN AND FOR THE COUNTY OF ${courtCounty.toUpperCase()}`),
    p(""),
    p(`Case No.: ${caseNo}`),
  ];

  const cellBorders = {
    top: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
    bottom: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
    left: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
    right: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
  };

  return new Table({
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: {
      top: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
      bottom: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
      left: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
      right: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
      insideHorizontal: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
      insideVertical: { style: BorderStyle.NONE, size: 0, color: "FFFFFF" },
    },
    rows: [
      new TableRow({
        children: [
          new TableCell({
            width: { size: 55, type: WidthType.PERCENTAGE },
            borders: cellBorders,
            children: leftLines,
          }),
          new TableCell({
            width: { size: 45, type: WidthType.PERCENTAGE },
            borders: cellBorders,
            children: rightLines,
          }),
        ],
      }),
    ],
  });
}

function titleBlock(payload: CourtDocxPayload) {
  const title = payload.document?.title || "DECLARATION";
  const subtitle = payload.document?.subtitle || "";
  const parts: Paragraph[] = [
    new Paragraph({
      children: [tr(title, { bold: true })],
      alignment: AlignmentType.CENTER,
      spacing: { line: DOUBLE_LINE, after: PARA_AFTER },
    }),
  ];
  if (subtitle.trim()) {
    parts.push(
      new Paragraph({
        children: [tr(subtitle, { bold: true })],
        alignment: AlignmentType.CENTER,
        spacing: { line: DOUBLE_LINE, after: PARA_AFTER },
      })
    );
  }
  return parts;
}

function signatureBlock(payload: CourtDocxPayload) {
  const date = payload.date || "__________";
  const filerName = payload.filer?.fullName || "__________";
  const isSelf = payload.filer?.isSelfRepresented ?? true;

  const addr = safeJoin(
    [
      payload.filer?.addressLine1,
      payload.filer?.addressLine2,
      safeJoin([payload.filer?.city, payload.filer?.state, payload.filer?.zip], ", "),
    ],
    "\n"
  );

  const phone = payload.filer?.phone ? `Phone: ${payload.filer.phone}` : "";
  const email = payload.filer?.email ? `Email: ${payload.filer.email}` : "";

  const attorney = payload.filer?.attorney || {};
  const attyLine = attorney.name ? attorney.name : "";
  const firmLine = attorney.firm ? attorney.firm : "";
  const barLine = attorney.barNumber ? `Bar No.: ${attorney.barNumber}` : "";
  const attyContact = safeJoin([attorney.phone ? `Phone: ${attorney.phone}` : "", attorney.email ? `Email: ${attorney.email}` : ""], "\n");
  const attyAddr = attorney.address ? attorney.address : "";

  const blocks: Paragraph[] = [
    ...blank(2),
    p(`DATED: ${date}`),
    ...blank(1),
    p("______________________________", { keepNext: true }),
    p(filerName),
  ];

  if (isSelf) {
    blocks.push(p("Self-Represented"));
    if (addr) blocks.push(p(addr));
    if (phone) blocks.push(p(phone));
    if (email) blocks.push(p(email));
  } else {
    // Attorney block
    if (attyLine) blocks.push(p(attyLine));
    if (firmLine) blocks.push(p(firmLine));
    if (barLine) blocks.push(p(barLine));
    if (attyAddr) blocks.push(p(attyAddr));
    if (attyContact) blocks.push(p(attyContact));
  }

  return blocks;
}

function footerWithPageNumbers() {
  return new Footer({
    children: [
      new Paragraph({
        alignment: AlignmentType.CENTER,
        spacing: { line: DOUBLE_LINE, after: 0 },
        children: [
          tr("Page "),
          PageNumber.CURRENT,
          tr(" of "),
          PageNumber.TOTAL_PAGES,
        ],
      }),
    ],
  });
}

/**
 * Creates a pleading-formatted DOCX:
 * - 1" margins
 * - Times New Roman 12pt
 * - True double spacing
 * - Caption block at top
 * - Centered title
 * - Footer with "Page X of Y"
 */
export async function buildCourtDocx(payload: CourtDocxPayload): Promise<Buffer> {
  const bodyParas: Paragraph[] = [];

  // Caption table
  bodyParas.push(new Paragraph({ children: [], spacing: { line: DOUBLE_LINE, after: 0 } }));
  bodyParas.push(new Paragraph({ children: [], spacing: { line: DOUBLE_LINE, after: 0 } }));
  // Table must be a direct child in the section, so we place it in children array later.

  // Title
  const titleParas = titleBlock(payload);

  // Main body paragraphs (double spaced, no extra after spacing)
  const contentLines = payload.body && payload.body.length ? payload.body : [" "];
  const contentParas = contentLines.map((line) => p(line || " "));

  // Signature
  const sigParas = signatureBlock(payload);

  const doc = new Document({
    sections: [
      {
        properties: {
          type: SectionType.CONTINUOUS,
          page: {
            margin: {
              top: ONE_INCH,
              bottom: ONE_INCH,
              left: ONE_INCH,
              right: ONE_INCH,
            },
          },
        },
        headers: {
          default: new Header({ children: [] }),
        },
        footers: {
          default: footerWithPageNumbers(),
        },
        children: [
          captionTable(payload),
          ...blank(1),
          ...titleParas,
          ...blank(1),
          ...contentParas,
          ...sigParas,
        ],
      },
    ],
  });

  return await Packer.toBuffer(doc);
}
EOF

# Ensure routes use the helper. This patch assumes your route file already exists with /api/templates/docx.
# We replace the handler body by searching for "app.post(\"/api/templates/docx\"" and inserting buildCourtDocx usage.
node <<'EOF'
const fs = require("fs");

const path = "server/routes.ts";
let s = fs.readFileSync(path, "utf8");

if (!s.includes("buildCourtDocx")) {
  // Add import near top (safe, idempotent-ish)
  s = s.replace(
    /import\s+\{[^}]*\}\s+from\s+"\.\/db";\n/,
    (m) => m + `import { buildCourtDocx } from "./courtDocx";\n`
  );
}

const re = /app\.post\(\s*["']\/api\/templates\/docx["']\s*,([\s\S]*?)\)\s*;\n/;
if (!re.test(s)) {
  console.error("Could not find /api/templates/docx route in server/routes.ts. Please locate it and update manually to call buildCourtDocx(payload).");
  process.exit(1);
}

s = s.replace(re, () => {
  return `app.post("/api/templates/docx", requireAuth, async (req, res) => {
  try {
    // Expecting the client to send a payload that matches CourtDocxPayload shape.
    // Do not copy any reference document text; we only format.
    const payload = req.body || {};

    const buf = await buildCourtDocx(payload);

    res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
    res.setHeader("Content-Disposition", "attachment; filename=court-document.docx");
    return res.status(200).send(buf);
  } catch (err) {
    console.error("DOCX generation error:", err);
    return res.status(500).json({ error: "Failed to generate DOCX" });
  }
});\n`;
});

fs.writeFileSync(path, s);
console.log("Updated server/routes.ts to use buildCourtDocx()");
EOF

echo ""
echo "Slice 4B(A) applied."
echo "Next: restart the Replit app, download a DOCX, and verify:"
echo "- Times New Roman 12pt"
echo "- Double spaced body"
echo "- 1-inch margins"
echo "- Caption block top-left and court/case block top-right"
echo "- Footer shows 'Page X of Y'"