REPLIT TASK: Full Front-End Audit (Routing + Link Integrity + Build Health)
Goal: confirm the entire front end is correct, routed, and not broken before starting backend work.

========================
A) Repo Health Checks
========================
1) Install + baseline checks
- Run:
  - npm ci || npm install
  - npm run lint (if exists)
  - npm run typecheck (if exists)
  - npm run build
  - npm run preview (or npm run start) and confirm site loads

2) Find the router definition(s)
- Locate where routes are declared (likely one of):
  - client/src/App.tsx
  - client/src/main.tsx
  - client/src/router.tsx
  - client/src/routes.tsx
- Confirm SPA fallback:
  - Production server must return index.html for non-API paths (so /privacy-policy doesn’t 404 on refresh)

========================
B) Automated Route + Link Audit
========================
Create this file: scripts/route-audit.mjs

--------------------------------
scripts/route-audit.mjs
--------------------------------
import fs from "node:fs";
import path from "node:path";

const ROOT = process.cwd();
const CLIENT_DIR = path.join(ROOT, "client", "src");

const exts = new Set([".ts", ".tsx", ".js", ".jsx"]);
const IGNORE_DIRS = new Set(["node_modules", "dist", "build", ".git", ".next", ".vite", "coverage"]);

function walk(dir, out = []) {
  if (!fs.existsSync(dir)) return out;
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    if (IGNORE_DIRS.has(e.name)) continue;
    const p = path.join(dir, e.name);
    if (e.isDirectory()) walk(p, out);
    else if (exts.has(path.extname(e.name))) out.push(p);
  }
  return out;
}

function read(file) {
  try { return fs.readFileSync(file, "utf8"); } catch { return ""; }
}

// Extract routes from common React Router patterns
function extractRoutesFromText(txt) {
  const routes = new Set();

  // <Route path="/x" ... />
  const routeTag = /<Route\b[^>]*\bpath\s*=\s*(\{?\s*["'`][^"'`]+["'`]\s*\}?)/g;
  let m;
  while ((m = routeTag.exec(txt))) {
    const raw = m[1].replace(/[{}]/g, "").trim();
    const p = raw.slice(1, -1); // remove quotes
    if (p) routes.add(p);
  }

  // createBrowserRouter([{ path: "/x", ... }])
  const objPath = /\bpath\s*:\s*["'`][^"'`]+["'`]/g;
  while ((m = objPath.exec(txt))) {
    const kv = m[0];
    const p = kv.split(":")[1].trim();
    const val = p.slice(1, -1);
    if (val) routes.add(val);
  }

  return routes;
}

// Extract internal links from <Link to="...">, href="/...", navigate("/...")
function extractLinksFromText(txt) {
  const links = new Set();

  // to="/x" or to={'/x'}
  const toAttr = /\bto\s*=\s*(\{?\s*["'`][^"'`]+["'`]\s*\}?)/g;
  let m;
  while ((m = toAttr.exec(txt))) {
    const raw = m[1].replace(/[{}]/g, "").trim();
    const p = raw.slice(1, -1);
    if (p.startsWith("/")) links.add(p);
  }

  // href="/x"
  const hrefAttr = /\bhref\s*=\s*(\{?\s*["'`][^"'`]+["'`]\s*\}?)/g;
  while ((m = hrefAttr.exec(txt))) {
    const raw = m[1].replace(/[{}]/g, "").trim();
    const p = raw.slice(1, -1);
    if (p.startsWith("/")) links.add(p);
  }

  // navigate("/x")
  const navCall = /\bnavigate\s*\(\s*["'`][^"'`]+["'`]\s*\)/g;
  while ((m = navCall.exec(txt))) {
    const inside = m[0].match(/["'`][^"'`]+["'`]/)?.[0];
    if (!inside) continue;
    const p = inside.slice(1, -1);
    if (p.startsWith("/")) links.add(p);
  }

  return links;
}

function normalize(p) {
  if (!p) return p;
  // treat "" as "/"
  if (p === "") return "/";
  // strip trailing slashes except root
  if (p.length > 1 && p.endsWith("/")) return p.slice(0, -1);
  return p;
}

const files = walk(CLIENT_DIR);
const allRoutes = new Set();
const allLinks = new Set();

for (const f of files) {
  const txt = read(f);
  for (const r of extractRoutesFromText(txt)) allRoutes.add(normalize(r));
  for (const l of extractLinksFromText(txt)) allLinks.add(normalize(l));
}

const routes = [...allRoutes].filter(Boolean).sort();
const links = [...allLinks].filter(Boolean).sort();

const missing = links.filter((l) => !allRoutes.has(l) && !l.startsWith("/api"));
const orphan = routes.filter((r) => !allLinks.has(r));

console.log("=== ROUTE AUDIT ===");
console.log("Routes found:", routes.length);
console.log("Links found:", links.length);
console.log("");

if (missing.length) {
  console.log("❌ Links that do NOT match any declared route (possible 404s):");
  for (const m of missing) console.log("  -", m);
  console.log("");
} else {
  console.log("✅ All internal links appear to map to declared routes.");
  console.log("");
}

if (orphan.length) {
  console.log("⚠️ Declared routes that are never linked (may be OK if navigated programmatically):");
  for (const o of orphan) console.log("  -", o);
  console.log("");
} else {
  console.log("✅ Every declared route is referenced by at least one link.");
  console.log("");
}

// Output a copy-paste list for manual testing
console.log("Manual test list (visit each):");
for (const r of routes) console.log("  -", r);

process.exit(missing.length ? 1 : 0);

--------------------------------

3) Add package.json script (if scripts exists)
- In package.json add:
  "audit:routes": "node scripts/route-audit.mjs"

4) Run it:
- npm run audit:routes
- Fix any missing routes or incorrect links until it passes (exit code 0)

========================
C) Routing + Refresh (Hard Requirement)
========================
Confirm production refresh works:
- Visit /privacy-policy (or any deep link) directly in the deployed/prod environment.
- Refresh the page.
- It MUST load (SPA fallback must serve index.html).

If it 404s on refresh:
- Fix the server/static hosting config to route all non-/api paths to the SPA index.

========================
D) UI/Content Consistency Checks
========================
1) Title Case in hero headings + buttons
- Ensure hero headings and CTA labels are Title Case consistently.
- Search for any hero headings with inconsistent casing and normalize.

2) Remove extra hero buttons
- Rule: prefer 0–1 primary CTA in hero blocks (avoid “Read”/scroll buttons).
- “Contact” pages can keep 1 clear CTA that goes to /contact or mailto.

========================
E) Smoke Test List (Must Pass)
========================
- No console errors on load (mobile + desktop)
- No 404s in Network tab for internal page navigation
- All forms validate and submit without crashing (even if backend is stubbed)
- Build completes cleanly
- Route audit passes
- Deep-link refresh passes

DELIVERABLE BACK TO PAIGE:
1) A list of all routes found (output from audit script)
2) Any broken links fixed + where
3) Confirmation deep-link refresh works in prod
4) Any remaining “TODO/stub” features in UI (so backend can implement cleanly)