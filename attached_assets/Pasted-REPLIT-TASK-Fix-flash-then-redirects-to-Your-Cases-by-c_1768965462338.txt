REPLIT TASK: Fix “flash then redirects to Your Cases” by correcting auth cookie handling + redirect guards

SYMPTOM:
- Clicking any app menu item briefly shows correct module page, then redirects to “Your Cases”
- Server logs show many 401 Unauthorized on /api/cases/:caseId/* requests during navigation

ROOT CAUSE (MOST LIKELY):
- Frontend fetch requests are NOT sending session cookies (credentials missing OR wrong base URL)
- Those 401s trigger global “no case selected / auth failed” logic which redirects to /app/cases

GOAL:
- Ensure ALL API calls include session cookies
- Ensure 401 leads to /login (session expired) instead of redirecting to /app/cases
- Prevent “auto redirect to cases” from firing due to transient 401s

────────────────────────
STEP 1 — FORCE COOKIES ON ALL CLIENT API CALLS
────────────────────────

Find the shared client API wrapper (one of these commonly exists):
- client/src/lib/api.ts
- client/src/lib/apiRequest.ts
- client/src/lib/queryClient.ts (default queryFn)
- anywhere using fetch() for /api/*

Make ONE centralized helper and use it everywhere:

- Always use RELATIVE URLs like "/api/..." (not absolute domains)
- Always set: credentials: "include"
- Always set Accept/Content-Type as needed

Example:

export async function apiFetch(path: string, init: RequestInit = {}) {
  const res = await fetch(path, {
    ...init,
    credentials: "include",
    headers: {
      "Accept": "application/json",
      ...(init.body ? { "Content-Type": "application/json" } : {}),
      ...(init.headers || {}),
    },
  });

  // handle 401 centrally (see Step 2)
  return res;
}

Then replace all fetch("/api/...") and apiRequest calls to go through apiFetch().

IMPORTANT:
Do NOT use "https://<replit-url>/api/..." from the frontend.
Using absolute URLs often breaks cookies.

────────────────────────
STEP 2 — CENTRALIZE 401 HANDLING: REDIRECT TO /login (NOT /app/cases)
────────────────────────

In that same apiFetch wrapper:

If res.status === 401:
- Clear any cached user state if needed
- Redirect to "/login?reason=session"
- Throw an error so callers stop and don’t run fallback redirects

Example:
if (res.status === 401) {
  window.location.href = "/login?reason=session";
  throw new Error("SESSION_INVALID");
}

Also ensure React Query does NOT treat 401 as “no case exists”.
It’s “not logged in”.

────────────────────────
STEP 3 — FIX THE “AUTO REDIRECT TO /app/cases” GUARD
────────────────────────

Search for logic like:
- ensureCaseSelected()
- redirectToFirstCase()
- if (!activeCaseId) setLocation("/app/cases")
- if (!case) setLocation("/app/cases")
- “case redirect” effect

Modify it so it only runs when:
- User is confirmed authenticated (profile loaded successfully)
- AND the API is not in a 401 state

Add a boolean like:
const isAuthed = profileQuery.isSuccess;  // or equivalent
const isAuthError = profileQuery.isError && error indicates 401

Then:
- If isAuthError → go /login
- Else if isAuthed and no case selected → go /app/cases
- Never redirect to /app/cases just because a case-scoped query failed

────────────────────────
STEP 4 — ADD TEMP DEBUG LOGGING TO FIND THE EXACT REDIRECT SOURCE
────────────────────────

Add a temporary console log at every redirect location:

console.log("[NAV REDIRECT]", { from: location.pathname, to: "/app/cases", reason: "noActiveCaseId" });

Also log when 401 occurs:
console.log("[API 401]", path);

This will pinpoint which file/effect is causing the redirect.

────────────────────────
STEP 5 — VERIFY
────────────────────────

After changes, restart app and test:

1) Login
2) Click Evidence / Timeline / Documents etc.
Expected:
- No 401 spam in logs
- No forced redirect to /app/cases
- Pages stay where clicked

If 401 persists even with credentials: "include":
- Then fix CORS/session cookie settings (SameSite/secure/domain) in server auth config
- But in SAME-ORIGIN setups this is usually just missing credentials or absolute URL usage.

END TASK