#!/usr/bin/env bash
# Civilla: Case Stub + Lite Onboarding + Lexi Intake + Served/Incoming Docs scaffolding
# Run from repo root in Replit Shell:
#   bash scripts/apply_case_stub_intake.sh
set -euo pipefail

TS="$(date +%Y%m%d_%H%M%S)"
mkdir -p scripts docs/lexi-onboarding \
  server/src/routes server/src/lib \
  client/src/pages client/src/components/lexi client/src/lib/lexi client/src/lib

backup_if_exists () {
  local path="$1"
  if [ -f "$path" ]; then
    cp "$path" "${path}.bak.${TS}"
    echo "Backed up: $path -> ${path}.bak.${TS}"
  fi
}

write () {
  local path="$1"
  shift
  backup_if_exists "$path"
  cat > "$path" <<'EOF'
'"$@"'
EOF
}

append_if_missing () {
  local file="$1"
  local needle="$2"
  local block="$3"
  if [ ! -f "$file" ]; then return 0; fi
  if grep -Fq "$needle" "$file"; then
    echo "Already present in $file: $needle"
  else
    printf "\n%s\n" "$block" >> "$file"
    echo "Appended to $file: $needle"
  fi
}

# ------------------------------------------------------------------------------
# 0) Documentation (what this change is)
# ------------------------------------------------------------------------------
write "docs/lexi-onboarding/CASE_STUB_INTAKE_PLAN.md" '
# Civilla ‚Äî Case Stub + Lite Onboarding + Lexi Intake + Served Intake

## What we are changing
We are shifting from heavy onboarding to:
1) minimal account + required consents + state,
2) Lexi intake (text or speech-to-text) that routes users to a Start Here hub,
3) Case Stub created early (so all existing case-scoped APIs keep working),
4) Served/intake upload pathway (incoming documents) that can later power ‚Äúidentify this document‚Äù and ‚Äútypical next steps.‚Äù

## Why
- Reduces user drop-off.
- Supports ‚ÄúI was served‚Äù users who don‚Äôt know what to do.
- Keeps UPL guardrails: options + education; no strategy selection.

## UPL guardrail line (must appear where drafting/export happens)
Prepared using Civilla for educational and research purposes. Not legal advice.

## New database objects
- intake_sessions: stores raw intake text + inferred intent + routing info.
- incoming_case_documents: stores served/uploaded files + classification + extracted metadata.
- draftMode flags on documents & generatedDocuments (default EVIDENCE_FREE).
- cases.is_stub boolean (default false) so we can create ‚ÄúCase Stub‚Äù rows safely.

## New API routes
- POST /api/intake/start
  Creates a Case Stub + Intake Session (caseId is returned).
- POST /api/cases/:caseId/incoming-documents
  Records uploaded/served document metadata (fileKey/url + optional classification).
- POST /api/incoming-documents/:docId/extract (stub)
  Placeholder for OCR/text extraction/classification.
- GET /api/cases/:caseId/next-steps?docId=...
  Returns ‚Äútypical options‚Äù based on classification (no directives).

## Frontend
New pages (scaffolded):
- /onboarding-lite
- /lexi
- /start

Wiring is repo-specific; this script attempts best-effort patches but also prints what to do.

## Health check after merge
- Did it work in local dev?
- Did anything break?
- Did it work on civilla.ai?
- Did refresh/login persist?
- Did mobile behavior break?
'

# ------------------------------------------------------------------------------
# 1) SQL Migration (Postgres) ‚Äî safe IF NOT EXISTS + ADD COLUMN IF NOT EXISTS
# ------------------------------------------------------------------------------
mkdir -p migrations
write "migrations/${TS}_case_stub_intake_and_incoming_docs.sql" '
-- Civilla: Case Stub + Intake + Incoming Docs + Draft Mode
-- Safe to re-run: uses IF NOT EXISTS / ADD COLUMN IF NOT EXISTS (Postgres)

-- 1) cases: add is_stub flag so we can create minimal case rows early
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = ''cases'') THEN
    ALTER TABLE cases
      ADD COLUMN IF NOT EXISTS is_stub boolean NOT NULL DEFAULT false;
    ALTER TABLE cases
      ADD COLUMN IF NOT EXISTS stub_origin text; -- e.g., "lexi_intake"
    ALTER TABLE cases
      ADD COLUMN IF NOT EXISTS stub_state text;  -- simple jurisdiction anchor if your cases table doesn‚Äôt already have state
  END IF;
END $$;

-- 2) documents: add draftMode + optional evidenceFree flag (default ON)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = ''documents'') THEN
    ALTER TABLE documents
      ADD COLUMN IF NOT EXISTS draft_mode text NOT NULL DEFAULT ''EVIDENCE_FREE'';
    ALTER TABLE documents
      ADD COLUMN IF NOT EXISTS evidence_free boolean NOT NULL DEFAULT true;
  END IF;
END $$;

-- 3) generatedDocuments: add draftMode
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = ''generateddocuments'')
     OR EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = ''generated_documents'') THEN
    -- handle either naming style
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = ''generateddocuments'') THEN
      ALTER TABLE generatedDocuments
        ADD COLUMN IF NOT EXISTS draft_mode text NOT NULL DEFAULT ''EVIDENCE_FREE'';
    END IF;
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = ''generated_documents'') THEN
      ALTER TABLE generated_documents
        ADD COLUMN IF NOT EXISTS draft_mode text NOT NULL DEFAULT ''EVIDENCE_FREE'';
    END IF;
  END IF;
END $$;

-- 4) intake_sessions
CREATE TABLE IF NOT EXISTS intake_sessions (
  id              varchar PRIMARY KEY,
  user_id         varchar NOT NULL,
  case_id         varchar,
  raw_intake_text text NOT NULL,
  intent          text NOT NULL DEFAULT ''UNKNOWN'',
  routing_json    jsonb NOT NULL DEFAULT ''{}''::jsonb,
  created_at      timestamp NOT NULL DEFAULT now(),
  updated_at      timestamp NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_intake_sessions_user_id ON intake_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_intake_sessions_case_id ON intake_sessions(case_id);

-- 5) incoming_case_documents
CREATE TABLE IF NOT EXISTS incoming_case_documents (
  id               varchar PRIMARY KEY,
  user_id          varchar NOT NULL,
  case_id          varchar,
  source_type      text NOT NULL DEFAULT ''user_upload'', -- served | user_upload | court_download
  file_key         text,      -- storage key
  file_url         text,      -- if you use signed urls
  original_name    text,
  parsed_text      text,
  classification   text NOT NULL DEFAULT ''unknown'', -- summons | petition | motion | order | unknown
  extracted_json   jsonb NOT NULL DEFAULT ''{}''::jsonb, -- court/case/deadlines/hearing
  created_at       timestamp NOT NULL DEFAULT now(),
  updated_at       timestamp NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_incoming_docs_user_id ON incoming_case_documents(user_id);
CREATE INDEX IF NOT EXISTS idx_incoming_docs_case_id ON incoming_case_documents(case_id);
CREATE INDEX IF NOT EXISTS idx_incoming_docs_classification ON incoming_case_documents(classification);

-- Optional FK constraints (only if users/cases tables exist with matching ids)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = ''users'')
     AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = ''cases'') THEN
    BEGIN
      ALTER TABLE intake_sessions
        ADD CONSTRAINT fk_intake_sessions_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;

    BEGIN
      ALTER TABLE intake_sessions
        ADD CONSTRAINT fk_intake_sessions_case FOREIGN KEY (case_id) REFERENCES cases(id) ON DELETE SET NULL;
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;

    BEGIN
      ALTER TABLE incoming_case_documents
        ADD CONSTRAINT fk_incoming_docs_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;

    BEGIN
      ALTER TABLE incoming_case_documents
        ADD CONSTRAINT fk_incoming_docs_case FOREIGN KEY (case_id) REFERENCES cases(id) ON DELETE SET NULL;
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;
  END IF;
END $$;
'

# ------------------------------------------------------------------------------
# 2) Server: DB compatibility (tries to find existing Pool; falls back to DATABASE_URL)
# ------------------------------------------------------------------------------
write "server/src/lib/sqlCompat.ts" '
import { Pool } from "pg";

// Best-effort: reuse an existing exported Pool if your repo already has one.
function tryRequire(path: string): any | null {
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    return require(path);
  } catch {
    return null;
  }
}

export function getPool(): Pool {
  const candidates = [
    "../db",
    "../db/index",
    "../lib/db",
    "../database",
    "../database/index",
    "./db",
    "./database",
  ];

  for (const c of candidates) {
    const mod = tryRequire(c);
    if (!mod) continue;
    const pool = mod.pool || mod.default?.pool || mod.POOL || mod.default?.POOL;
    if (pool) return pool as Pool;
  }

  // Fallback: create our own Pool (works if DATABASE_URL is set)
  const url = process.env.DATABASE_URL;
  if (!url) {
    throw new Error("DATABASE_URL is not set and no existing pool export was found.");
  }
  return new Pool({ connectionString: url });
}
'

# ------------------------------------------------------------------------------
# 3) Server: simple id generator (UUID v4 without extra deps)
# ------------------------------------------------------------------------------
write "server/src/lib/id.ts" '
import crypto from "crypto";

// RFC4122-ish UUIDv4 using Node crypto (no external deps)
export function uuid(): string {
  const bytes = crypto.randomBytes(16);
  bytes[6] = (bytes[6] & 0x0f) | 0x40;
  bytes[8] = (bytes[8] & 0x3f) | 0x80;
  const hex = bytes.toString("hex");
  return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
}
'

# ------------------------------------------------------------------------------
# 4) Server: Lexi deterministic classifier (same intent set as frontend)
# ------------------------------------------------------------------------------
write "server/src/lib/lexiIntent.ts" '
export type LexiIntent =
  | "SERVED_PAPERS"
  | "FILE_OR_SERVE"
  | "CHILD_SUPPORT_MODIFICATION"
  | "DIVORCE_FILING"
  | "DIVORCE_RESPONSE"
  | "UNKNOWN";

const norm = (s: string) =>
  s
    .toLowerCase()
    .replace(/[^\p{L}\p{N}\s]/gu, " ")
    .replace(/\s+/g, " ")
    .trim();

const hasAny = (text: string, phrases: string[]) => phrases.some((p) => text.includes(p));

export function classify(raw: string): { intent: LexiIntent; confidence: number; reasons: string[] } {
  const text = norm(raw || "");
  if (!text) return { intent: "UNKNOWN", confidence: 0, reasons: ["empty_input"] };

  const served = hasAny(text, ["served", "got served", "served papers", "summons", "complaint", "petition", "divorce papers", "papers i received"]);
  const respond = hasAny(text, ["answer", "respond", "response", "court date", "hearing", "deadline"]);
  const file = hasAny(text, ["file", "filing", "start divorce", "initiate", "serve someone", "serve my spouse", "serve the other party"]);
  const divorce = hasAny(text, ["divorce", "dissolution", "separation"]);
  const childSupport = hasAny(text, ["child support", "support modification", "modify support", "change child support", "arrears"]);

  if (served) return { intent: "SERVED_PAPERS", confidence: respond ? 0.85 : 0.75, reasons: ["mentions_served_or_received_papers"] };
  if (childSupport) return { intent: "CHILD_SUPPORT_MODIFICATION", confidence: 0.8, reasons: ["mentions_child_support_modification"] };
  if (file && divorce) return { intent: "DIVORCE_FILING", confidence: 0.75, reasons: ["mentions_filing_divorce"] };
  if (respond && divorce) return { intent: "DIVORCE_RESPONSE", confidence: 0.75, reasons: ["mentions_responding_divorce"] };
  if (file) return { intent: "FILE_OR_SERVE", confidence: 0.65, reasons: ["mentions_file_or_serve"] };
  return { intent: "UNKNOWN", confidence: 0.4, reasons: ["no_strong_keywords"] };
}
'

# ------------------------------------------------------------------------------
# 5) Server Routes:
#    - /api/intake/start -> creates Case Stub + Intake Session
#    - /api/cases/:caseId/incoming-documents -> records served/uploaded docs
#    - /api/incoming-documents/:docId/extract -> placeholder
#    - /api/cases/:caseId/next-steps -> typical options (no directives)
# ------------------------------------------------------------------------------
write "server/src/routes/intake.ts" '
import { Router, Request, Response } from "express";
import { getPool } from "../lib/sqlCompat";
import { uuid } from "../lib/id";
import { classify } from "../lib/lexiIntent";

export const intakeRouter = Router();

/**
 * POST /api/intake/start
 * Body: { userId: string, state?: string, rawIntakeText: string }
 *
 * Creates:
 * - a Case Stub row in cases (best-effort insert with fallback columns)
 * - an intake_sessions row linked to that case
 *
 * NOTE: This endpoint assumes you pass a trusted userId (e.g., from session middleware).
 * In production, replace body.userId with req.user.id (or equivalent).
 */
intakeRouter.post("/start", async (req: Request, res: Response) => {
  const pool = getPool();
  const body = req.body || {};
  const userId = String(body.userId || "").trim();
  const rawIntakeText = String(body.rawIntakeText || "").trim();
  const state = body.state ? String(body.state).trim() : null;

  if (!userId) return res.status(400).json({ ok: false, error: "userId_required" });
  if (!rawIntakeText) return res.status(400).json({ ok: false, error: "rawIntakeText_required" });

  const caseId = uuid();
  const intakeId = uuid();
  const classification = classify(rawIntakeText);

  // 1) Create case stub ‚Äî best-effort, resilient to unknown cases schema.
  // Try most complete insert first; fall back to minimal columns.
  const createdAt = new Date();
  const title = "Case (stub)";

  const tryInsert = async (sql: string, params: any[]) => {
    try {
      await pool.query(sql, params);
      return true;
    } catch {
      return false;
    }
  };

  const inserted =
    (await tryInsert(
      `INSERT INTO cases (id, userId, title, createdAt, updatedAt, is_stub, stub_origin, stub_state)
       VALUES ($1,$2,$3,$4,$5,true,$6,$7)`,
      [caseId, userId, title, createdAt, createdAt, "lexi_intake", state]
    )) ||
    (await tryInsert(
      `INSERT INTO cases (id, userId, title, createdAt, updatedAt, is_stub)
       VALUES ($1,$2,$3,$4,$5,true)`,
      [caseId, userId, title, createdAt, createdAt]
    )) ||
    (await tryInsert(
      `INSERT INTO cases (id, userId, createdAt, updatedAt, is_stub)
       VALUES ($1,$2,$3,$4,true)`,
      [caseId, userId, createdAt, createdAt]
    )) ||
    (await tryInsert(
      `INSERT INTO cases (id, userId, createdAt, updatedAt)
       VALUES ($1,$2,$3,$4)`,
      [caseId, userId, createdAt, createdAt]
    ));

  if (!inserted) {
    return res.status(500).json({
      ok: false,
      error: "case_stub_insert_failed",
      note: "Your cases table schema likely differs. Update the INSERT columns in server/src/routes/intake.ts to match.",
    });
  }

  // 2) Insert intake session
  await pool.query(
    `INSERT INTO intake_sessions (id, user_id, case_id, raw_intake_text, intent, routing_json, created_at, updated_at)
     VALUES ($1,$2,$3,$4,$5,$6::jsonb, now(), now())`,
    [
      intakeId,
      userId,
      caseId,
      rawIntakeText,
      classification.intent,
      JSON.stringify({ offered: ["start_here", "upload_papers"], confidence: classification.confidence }),
    ]
  );

  return res.json({
    ok: true,
    caseId,
    intakeId,
    intent: classification.intent,
    confidence: classification.confidence,
    reasons: classification.reasons,
  });
});
'

write "server/src/routes/incomingDocuments.ts" '
import { Router, Request, Response } from "express";
import { getPool } from "../lib/sqlCompat";
import { uuid } from "../lib/id";

export const incomingDocumentsRouter = Router();

/**
 * POST /api/cases/:caseId/incoming-documents
 * Body: { userId: string, sourceType?: string, fileKey?: string, fileUrl?: string, originalName?: string, classification?: string, extractedJson?: object }
 *
 * NOTE: This does NOT implement file upload; it records metadata after your existing upload mechanism returns a fileKey/url.
 * In production: userId should come from auth/session, not body.
 */
incomingDocumentsRouter.post("/cases/:caseId/incoming-documents", async (req: Request, res: Response) => {
  const pool = getPool();
  const { caseId } = req.params;

  const body = req.body || {};
  const userId = String(body.userId || "").trim();
  if (!userId) return res.status(400).json({ ok: false, error: "userId_required" });

  const id = uuid();
  const sourceType = String(body.sourceType || "user_upload");
  const fileKey = body.fileKey ? String(body.fileKey) : null;
  const fileUrl = body.fileUrl ? String(body.fileUrl) : null;
  const originalName = body.originalName ? String(body.originalName) : null;
  const classification = String(body.classification || "unknown");
  const extractedJson = body.extractedJson ? JSON.stringify(body.extractedJson) : "{}";

  await pool.query(
    `INSERT INTO incoming_case_documents
     (id, user_id, case_id, source_type, file_key, file_url, original_name, classification, extracted_json, created_at, updated_at)
     VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9::jsonb, now(), now())`,
    [id, userId, caseId, sourceType, fileKey, fileUrl, originalName, classification, extractedJson]
  );

  return res.json({ ok: true, id });
});

/**
 * POST /api/incoming-documents/:docId/extract (stub)
 * Placeholder for OCR/text extraction + classification.
 */
incomingDocumentsRouter.post("/incoming-documents/:docId/extract", async (req: Request, res: Response) => {
  const pool = getPool();
  const { docId } = req.params;

  // Stub: mark as "processed" with no extraction
  await pool.query(
    `UPDATE incoming_case_documents
     SET updated_at = now()
     WHERE id = $1`,
    [docId]
  );

  return res.json({ ok: true, docId, note: "Extraction/classification not implemented yet." });
});
'

write "server/src/routes/nextSteps.ts" '
import { Router, Request, Response } from "express";
import { getPool } from "../lib/sqlCompat";

export const nextStepsRouter = Router();

const DISCLAIMER = "Prepared using Civilla for educational and research purposes. Not legal advice.";

function typicalOptionsFor(classification: string) {
  const base = [
    { key: "start_here", label: "Go to Start Here", description: "Choose a common path and see typical steps (varies by state/court)." },
    { key: "organize_docs", label: "Organize documents & dates", description: "Collect key dates, parties, and court info in one place." },
  ];

  switch ((classification || "").toLowerCase()) {
    case "summons":
    case "petition":
      return [
        ...base,
        { key: "draft_answer", label: "Draft an Answer (evidence-free)", description: "Create a structured response from your selections. No exhibits by default." },
        { key: "review_deadlines", label: "Review deadlines", description: "See common deadline concepts and verify what your papers say." },
      ];
    case "motion":
      return [
        ...base,
        { key: "identify_motion", label: "Identify motion type", description: "See common motion categories and what people typically prepare." },
        { key: "hearing_prep", label: "Hearing prep checklist", description: "Organize what is commonly helpful for hearings (varies by court)." },
      ];
    case "order":
      return [
        ...base,
        { key: "understand_order", label: "Understand the order", description: "Learn typical terms and what orders often do (varies by state/court)." },
      ];
    default:
      return [
        ...base,
        { key: "upload_more", label: "Upload more pages", description: "If something is missing, upload additional pages so fields can be identified." },
      ];
  }
}

/**
 * GET /api/cases/:caseId/next-steps?docId=...
 * Returns educational options (no directives).
 */
nextStepsRouter.get("/cases/:caseId/next-steps", async (req: Request, res: Response) => {
  const pool = getPool();
  const { caseId } = req.params;
  const docId = req.query.docId ? String(req.query.docId) : null;

  let classification = "unknown";
  if (docId) {
    const r = await pool.query(
      `SELECT classification FROM incoming_case_documents WHERE id = $1 AND case_id = $2 LIMIT 1`,
      [docId, caseId]
    );
    classification = r.rows?.[0]?.classification || "unknown";
  }

  return res.json({
    ok: true,
    caseId,
    docId,
    classification,
    options: typicalOptionsFor(classification),
    disclaimer: DISCLAIMER,
  });
});
'

# ------------------------------------------------------------------------------
# 6) Client: Lexi intake + speech-to-text + Start Here (as scaffold)
#     - Adds case stub creation API call (POST /api/intake/start)
# ------------------------------------------------------------------------------
write "client/src/lib/intakeApi.ts" '
export interface IntakeStartResponse {
  ok: boolean;
  caseId?: string;
  intakeId?: string;
  intent?: string;
  confidence?: number;
  reasons?: string[];
  error?: string;
  note?: string;
}

export async function startIntake(params: {
  userId: string; // TEMP: replace with session-derived identity
  state?: string;
  rawIntakeText: string;
}): Promise<IntakeStartResponse> {
  const res = await fetch("/api/intake/start", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(params),
  });
  return res.json();
}
'

write "client/src/lib/lexi/classify.ts" '
export type LexiIntent =
  | "SERVED_PAPERS"
  | "FILE_OR_SERVE"
  | "CHILD_SUPPORT_MODIFICATION"
  | "DIVORCE_FILING"
  | "DIVORCE_RESPONSE"
  | "UNKNOWN";

export interface LexiClassification {
  intent: LexiIntent;
  confidence: number;
  reasons: string[];
}

const norm = (s: string) =>
  s
    .toLowerCase()
    .replace(/[^\p{L}\p{N}\s]/gu, " ")
    .replace(/\s+/g, " ")
    .trim();

const hasAny = (text: string, phrases: string[]) =>
  phrases.some((p) => text.includes(p));

export function classifyLexiIntent(raw: string): LexiClassification {
  const text = norm(raw);
  if (!text) return { intent: "UNKNOWN", confidence: 0, reasons: ["empty_input"] };

  const served = hasAny(text, ["served", "got served", "served papers", "summons", "complaint", "petition", "divorce papers", "papers i received"]);
  const respond = hasAny(text, ["answer", "respond", "response", "court date", "hearing", "deadline"]);
  const file = hasAny(text, ["file", "filing", "start divorce", "initiate", "serve someone", "serve my spouse", "serve the other party"]);
  const divorce = hasAny(text, ["divorce", "dissolution", "separation"]);
  const childSupport = hasAny(text, ["child support", "support modification", "modify support", "change child support", "arrears"]);

  if (served) return { intent: "SERVED_PAPERS", confidence: respond ? 0.85 : 0.75, reasons: ["mentions_served_or_received_papers"] };
  if (childSupport) return { intent: "CHILD_SUPPORT_MODIFICATION", confidence: 0.8, reasons: ["mentions_child_support_modification"] };
  if (file && divorce) return { intent: "DIVORCE_FILING", confidence: 0.75, reasons: ["mentions_filing_divorce"] };
  if (respond && divorce) return { intent: "DIVORCE_RESPONSE", confidence: 0.75, reasons: ["mentions_responding_divorce"] };
  if (file) return { intent: "FILE_OR_SERVE", confidence: 0.65, reasons: ["mentions_file_or_serve"] };
  return { intent: "UNKNOWN", confidence: 0.4, reasons: ["no_strong_keywords"] };
}
'

write "client/src/components/lexi/useSpeechToText.ts" '
import { useCallback, useMemo, useRef, useState } from "react";

type SpeechRecognitionType = any;

export function useSpeechToText() {
  const [isSupported] = useState(() => {
    return typeof window !== "undefined" && ("webkitSpeechRecognition" in window || "SpeechRecognition" in window);
  });
  const [isListening, setIsListening] = useState(false);
  const [transcript, setTranscript] = useState("");
  const [error, setError] = useState<string | null>(null);

  const recognitionRef = useRef<SpeechRecognitionType | null>(null);

  const SpeechRecognitionCtor = useMemo(() => {
    const w = window as any;
    return w.SpeechRecognition || w.webkitSpeechRecognition || null;
  }, []);

  const start = useCallback(() => {
    if (!SpeechRecognitionCtor) return;
    setError(null);

    const recognition = new SpeechRecognitionCtor();
    recognitionRef.current = recognition;

    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = "en-US";

    recognition.onstart = () => setIsListening(true);
    recognition.onerror = (e: any) => {
      setError(e?.error || "speech_error");
      setIsListening(false);
    };
    recognition.onend = () => setIsListening(false);

    recognition.onresult = (event: any) => {
      let text = "";
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const res = event.results[i];
        text += res[0]?.transcript ?? "";
      }
      setTranscript((prev) => (prev ? `${prev} ${text}`.trim() : text.trim()));
    };

    recognition.start();
  }, [SpeechRecognitionCtor]);

  const stop = useCallback(() => {
    recognitionRef.current?.stop?.();
    setIsListening(false);
  }, []);

  const reset = useCallback(() => {
    setTranscript("");
    setError(null);
  }, []);

  return { isSupported, isListening, transcript, error, start, stop, reset };
}
'

write "client/src/pages/OnboardingLite.tsx" '
import React, { useState } from "react";
import { Link, useNavigate } from "react-router-dom";

const DISCLAIMER = "Prepared using Civilla for educational and research purposes. Not legal advice.";

export default function OnboardingLite() {
  const nav = useNavigate();
  const [state, setState] = useState("");
  const [tos, setTos] = useState(false);
  const [privacy, setPrivacy] = useState(false);
  const [upl, setUpl] = useState(false);
  const [comms, setComms] = useState(false);

  const canContinue = state && tos && privacy && upl;

  return (
    <div style={{ maxWidth: 720, margin: "0 auto", padding: 16 }}>
      <h1 style={{ fontSize: 28, marginBottom: 8 }}>Quick setup</h1>
      <p style={{ opacity: 0.8, marginBottom: 16 }}>
        Minimal setup now. You can add case details later when you draft or organize.
      </p>

      <div style={{ border: "1px solid rgba(0,0,0,0.1)", borderRadius: 16, padding: 16 }}>
        <label style={{ display: "block", fontWeight: 600, marginBottom: 8 }}>State (jurisdiction anchor)</label>
        <input
          value={state}
          onChange={(e) => setState(e.target.value)}
          placeholder="Example: Idaho"
          style={{ width: "100%", borderRadius: 12, padding: 12, border: "1px solid rgba(0,0,0,0.15)" }}
        />

        <div style={{ marginTop: 16, display: "grid", gap: 10 }}>
          <label style={{ display: "flex", gap: 10, alignItems: "flex-start" }}>
            <input type="checkbox" checked={tos} onChange={(e) => setTos(e.target.checked)} />
            <span>I agree to the Terms of Service.</span>
          </label>

          <label style={{ display: "flex", gap: 10, alignItems: "flex-start" }}>
            <input type="checkbox" checked={privacy} onChange={(e) => setPrivacy(e.target.checked)} />
            <span>I acknowledge the Privacy Policy.</span>
          </label>

          <label style={{ display: "flex", gap: 10, alignItems: "flex-start" }}>
            <input type="checkbox" checked={upl} onChange={(e) => setUpl(e.target.checked)} />
            <span>Civilla is not a law firm and does not provide legal advice.</span>
          </label>

          <label style={{ display: "flex", gap: 10, alignItems: "flex-start" }}>
            <input type="checkbox" checked={comms} onChange={(e) => setComms(e.target.checked)} />
            <span>Optional: I consent to receive account messages by email/SMS (you can change this later).</span>
          </label>
        </div>

        <div style={{ marginTop: 16, padding: 12, borderRadius: 12, background: "rgba(0,0,0,0.03)" }}>
          <strong>Safety note:</strong> Civilla is not an emergency service. If you are in immediate danger, call local emergency services.
        </div>

        <div style={{ display: "flex", gap: 10, marginTop: 16, flexWrap: "wrap" }}>
          <button
            type="button"
            disabled={!canContinue}
            onClick={() => nav("/lexi", { state: { jurisdictionState: state } })}
            style={{
              padding: "10px 14px",
              borderRadius: 12,
              border: "1px solid rgba(0,0,0,0.2)",
              cursor: canContinue ? "pointer" : "not-allowed",
              opacity: canContinue ? 1 : 0.5
            }}
          >
            Continue to Lexi
          </button>

          <Link to="/start" style={{ textDecoration: "none" }}>
            <button style={{ padding: "10px 14px", borderRadius: 12, border: "1px solid rgba(0,0,0,0.2)", cursor: "pointer" }}>
              Skip to Start Here
            </button>
          </Link>
        </div>

        <p style={{ marginTop: 12, fontSize: 12, opacity: 0.75 }}>{DISCLAIMER}</p>
      </div>
    </div>
  );
}
'

write "client/src/pages/LexiIntake.tsx" '
import React, { useMemo, useState } from "react";
import { useLocation, useNavigate } from "react-router-dom";
import { classifyLexiIntent } from "../lib/lexi/classify";
import { useSpeechToText } from "../components/lexi/useSpeechToText";
import { startIntake } from "../lib/intakeApi";

const DISCLAIMER = "Prepared using Civilla for educational and research purposes. Not legal advice.";

export default function LexiIntake() {
  const nav = useNavigate();
  const loc: any = useLocation();
  const jurisdictionState = loc?.state?.jurisdictionState as string | undefined;

  const [input, setInput] = useState("");
  const [userId, setUserId] = useState(""); // TEMP: replace with session user id
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  const stt = useSpeechToText();
  const classification = useMemo(() => classifyLexiIntent(input), [input]);

  const mergeTranscript = () => {
    if (!stt.transcript) return;
    setInput((prev) => (prev ? `${prev}\n${stt.transcript}` : stt.transcript));
    stt.reset();
  };

  const run = async () => {
    setErr(null);
    setLoading(true);
    try {
      const resp = await startIntake({
        userId,
        state: jurisdictionState,
        rawIntakeText: input,
      });

      if (!resp.ok || !resp.caseId) {
        setErr(resp.error || resp.note || "Unable to start intake.");
        setLoading(false);
        return;
      }

      // Route to Start Here with caseId attached
      // Start Here can use caseId to attach incoming documents & builder flows.
      nav(`/start?caseId=${encodeURIComponent(resp.caseId)}&intent=${encodeURIComponent(resp.intent || "UNKNOWN")}`);
    } catch (e: any) {
      setErr(e?.message || "Network error");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ maxWidth: 720, margin: "0 auto", padding: 16 }}>
      <h1 style={{ fontSize: 28, marginBottom: 8 }}>Tell Lexi what‚Äôs going on</h1>
      <p style={{ opacity: 0.8, marginBottom: 16 }}>
        Type or use speech-to-text. Lexi will create a Case Stub and route you to Start Here.
      </p>

      <div style={{ border: "1px solid rgba(0,0,0,0.1)", borderRadius: 16, padding: 16 }}>
        <label style={{ display: "block", fontWeight: 600, marginBottom: 8 }}>
          Temporary dev field: userId
        </label>
        <input
          value={userId}
          onChange={(e) => setUserId(e.target.value)}
          placeholder="Paste your userId (temporary). Replace with session-derived user id."
          style={{ width: "100%", borderRadius: 12, padding: 12, border: "1px solid rgba(0,0,0,0.15)", marginBottom: 12 }}
        />

        <label style={{ display: "block", fontWeight: 600, marginBottom: 8 }}>
          What‚Äôs happening?
        </label>
        <textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Example: I was served divorce papers. Or: I want to modify child support."
          rows={6}
          style={{ width: "100%", borderRadius: 12, padding: 12, border: "1px solid rgba(0,0,0,0.15)" }}
        />

        <div style={{ display: "flex", gap: 8, flexWrap: "wrap", marginTop: 12, alignItems: "center" }}>
          <button
            type="button"
            onClick={run}
            disabled={loading || !input.trim() || !userId.trim()}
            style={{
              padding: "10px 14px",
              borderRadius: 12,
              border: "1px solid rgba(0,0,0,0.2)",
              cursor: loading ? "wait" : "pointer",
              opacity: (!input.trim() || !userId.trim()) ? 0.5 : 1
            }}
          >
            {loading ? "Starting‚Ä¶" : "Ask Lexi"}
          </button>

          {stt.isSupported ? (
            <>
              {!stt.isListening ? (
                <button
                  type="button"
                  onClick={stt.start}
                  style={{ padding: "10px 14px", borderRadius: 12, border: "1px solid rgba(0,0,0,0.2)", cursor: "pointer" }}
                >
                  üéôÔ∏è Start speech-to-text
                </button>
              ) : (
                <button
                  type="button"
                  onClick={stt.stop}
                  style={{ padding: "10px 14px", borderRadius: 12, border: "1px solid rgba(0,0,0,0.2)", cursor: "pointer" }}
                >
                  ‚èπÔ∏è Stop
                </button>
              )}

              <button
                type="button"
                onClick={mergeTranscript}
                disabled={!stt.transcript}
                style={{ padding: "10px 14px", borderRadius: 12, border: "1px solid rgba(0,0,0,0.2)", cursor: "pointer", opacity: stt.transcript ? 1 : 0.5 }}
              >
                Add transcript
              </button>
            </>
          ) : (
            <span style={{ opacity: 0.7 }}>Speech-to-text not supported in this browser.</span>
          )}
        </div>

        <p style={{ marginTop: 10, opacity: 0.75 }}>
          Local classification: <strong>{classification.intent}</strong> (confidence {classification.confidence})
        </p>

        {err ? <p style={{ color: "crimson", marginTop: 8 }}>{err}</p> : null}
        <p style={{ marginTop: 12, fontSize: 12, opacity: 0.75 }}>{DISCLAIMER}</p>
      </div>
    </div>
  );
}
'

write "client/src/pages/StartHere.tsx" '
import React, { useMemo, useState } from "react";
import { Link, useLocation } from "react-router-dom";

const DISCLAIMER = "Prepared using Civilla for educational and research purposes. Not legal advice.";

function useQuery() {
  const { search } = useLocation();
  return useMemo(() => new URLSearchParams(search), [search]);
}

export default function StartHere() {
  const q = useQuery();
  const caseId = q.get("caseId");
  const intent = q.get("intent");

  const [userId, setUserId] = useState(""); // TEMP: replace with session user id

  return (
    <div style={{ maxWidth: 920, margin: "0 auto", padding: 16 }}>
      <h1 style={{ fontSize: 28, marginBottom: 8 }}>Start Here</h1>
      <p style={{ opacity: 0.8, marginBottom: 12 }}>
        Choose a path. Civilla provides educational, jurisdiction-aware options ‚Äî you stay in control of decisions.
      </p>

      <div style={{ marginBottom: 12, padding: 12, borderRadius: 12, background: "rgba(0,0,0,0.03)" }}>
        <div><strong>Case Stub:</strong> {caseId ? caseId : "(none yet)"} </div>
        <div><strong>Intent:</strong> {intent || "(unknown)"} </div>
        <div style={{ marginTop: 8 }}>
          <label style={{ display: "block", fontWeight: 600, marginBottom: 6 }}>Temporary dev field: userId</label>
          <input
            value={userId}
            onChange={(e) => setUserId(e.target.value)}
            placeholder="Paste your userId (temporary). Replace with session-derived user id."
            style={{ width: "100%", borderRadius: 12, padding: 10, border: "1px solid rgba(0,0,0,0.15)" }}
          />
        </div>
      </div>

      <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(260px, 1fr))", gap: 12 }}>
        <div style={{ border: "1px solid rgba(0,0,0,0.1)", borderRadius: 16, padding: 16 }}>
          <h2 style={{ fontSize: 18, marginBottom: 6 }}>I was served papers</h2>
          <p style={{ opacity: 0.8, marginBottom: 12 }}>
            Upload what you received so Civilla can help identify it and show typical next steps (varies by state/court).
          </p>
          <Link to={caseId ? `/start?caseId=${encodeURIComponent(caseId)}&path=served` : "/lexi"} style={{ textDecoration: "none" }}>
            <button style={{ padding: "10px 14px", borderRadius: 12, border: "1px solid rgba(0,0,0,0.2)", cursor: "pointer" }}>
              Upload papers (metadata)
            </button>
          </Link>
          <p style={{ marginTop: 10, fontSize: 12, opacity: 0.7 }}>
            Note: upload UI is not implemented here; your existing upload mechanism should POST metadata to
            <code> /api/cases/:caseId/incoming-documents</code>.
          </p>
        </div>

        <div style={{ border: "1px solid rgba(0,0,0,0.1)", borderRadius: 16, padding: 16 }}>
          <h2 style={{ fontSize: 18, marginBottom: 6 }}>I need to file / serve papers</h2>
          <p style={{ opacity: 0.8, marginBottom: 12 }}>
            Learn typical filing steps and generate evidence-free drafts from your selections.
          </p>
          <button
            type="button"
            onClick={() => alert("Wire this to your Document Builder with draft_mode=EVIDENCE_FREE and new templates (petition/answer).")}
            style={{ padding: "10px 14px", borderRadius: 12, border: "1px solid rgba(0,0,0,0.2)", cursor: "pointer" }}
          >
            Start filing path
          </button>
        </div>

        <div style={{ border: "1px solid rgba(0,0,0,0.1)", borderRadius: 16, padding: 16 }}>
          <h2 style={{ fontSize: 18, marginBottom: 6 }}>Child support modification</h2>
          <p style={{ opacity: 0.8, marginBottom: 12 }}>
            See typical steps and what information is commonly needed to request a modification.
          </p>
          <button
            type="button"
            onClick={() => alert("Wire this to your Support Modification hub (education + organizer + evidence-free draft templates).")}
            style={{ padding: "10px 14px", borderRadius: 12, border: "1px solid rgba(0,0,0,0.2)", cursor: "pointer" }}
          >
            Start modification path
          </button>
        </div>

        <div style={{ border: "1px solid rgba(0,0,0,0.1)", borderRadius: 16, padding: 16 }}>
          <h2 style={{ fontSize: 18, marginBottom: 6 }}>Talk to Lexi again</h2>
          <p style={{ opacity: 0.8, marginBottom: 12 }}>
            Not sure which path fits? Tell Lexi what‚Äôs going on and get routing.
          </p>
          <Link to="/lexi" style={{ textDecoration: "none" }}>
            <button style={{ padding: "10px 14px", borderRadius: 12, border: "1px solid rgba(0,0,0,0.2)", cursor: "pointer" }}>
              Open Lexi Intake
            </button>
          </Link>
        </div>
      </div>

      <p style={{ marginTop: 16, fontSize: 12, opacity: 0.75 }}>{DISCLAIMER}</p>
    </div>
  );
}
'

# ------------------------------------------------------------------------------
# 7) Best-effort server mounting (does NOT assume exact app file path)
# ------------------------------------------------------------------------------
echo "Searching for Express app entry to mount new routers..."
ENTRY_CANDIDATES=$(grep -RIl --exclude-dir=node_modules --exclude-dir=dist --exclude='*.bak.*' "express()" server/src src 2>/dev/null || true)

mount_block='
// --- Civilla: Case Stub + Intake + Incoming Docs (auto-mounted) ---
import { intakeRouter } from "./routes/intake";
import { incomingDocumentsRouter } from "./routes/incomingDocuments";
import { nextStepsRouter } from "./routes/nextSteps";

app.use("/api/intake", intakeRouter);
app.use("/api", incomingDocumentsRouter);
app.use("/api", nextStepsRouter);
// --- end Civilla intake mount ---
'

if [ -n "${ENTRY_CANDIDATES}" ]; then
  # pick first candidate
  ENTRY_FILE="$(echo "${ENTRY_CANDIDATES}" | head -n 1)"
  echo "Found entry candidate: ${ENTRY_FILE}"

  # Insert imports/mounts if we find a line containing "const app" or "app =" etc.
  if grep -Fq "Civilla: Case Stub + Intake + Incoming Docs" "$ENTRY_FILE"; then
    echo "Router mount already present in ${ENTRY_FILE}"
  else
    # naive approach: append at end of file; dev will move it if needed.
    printf "\n%s\n" "$mount_block" >> "$ENTRY_FILE"
    echo "Appended router mounts to: ${ENTRY_FILE}"
  fi
else
  echo "No Express entry file found automatically. You must mount routes manually (see output below)."
fi

# ------------------------------------------------------------------------------
# 8) Best-effort client route wiring hint (does not patch automatically)
# ------------------------------------------------------------------------------
echo
echo "‚úÖ Files created."
echo
echo "NEXT ACTIONS (you must do these in your repo):"
cat <<'OUT'
1) Apply SQL migration using your existing migration workflow:
   - File created: migrations/<timestamp>_case_stub_intake_and_incoming_docs.sql
   - If you use a migrations runner, add it and run.
   - If you apply manually, run it against Postgres.

2) Ensure server has JSON body parsing:
   - app.use(express.json()) should be enabled before routes.

3) Ensure the new routes are mounted (if the script didn't find your entry file):
   - In your Express bootstrap (often server/src/index.ts or server/src/app.ts):
     import { intakeRouter } from "./routes/intake";
     import { incomingDocumentsRouter } from "./routes/incomingDocuments";
     import { nextStepsRouter } from "./routes/nextSteps";

     app.use("/api/intake", intakeRouter);
     app.use("/api", incomingDocumentsRouter);
     app.use("/api", nextStepsRouter);

4) Wire client routes (React Router):
   - /onboarding-lite -> client/src/pages/OnboardingLite.tsx
   - /lexi            -> client/src/pages/LexiIntake.tsx
   - /start           -> client/src/pages/StartHere.tsx

5) Replace TEMP userId fields:
   - In LexiIntake.tsx and StartHere.tsx, we used a temporary input for userId.
   - Replace that with your auth/session user id (req.user.id pattern server-side; client can omit userId entirely).

6) Document Builder upgrades (2‚Äì6 you asked for):
   A) Case Stub: now created by /api/intake/start (caseId returned)
   B) Incoming docs: record served uploads with /api/cases/:caseId/incoming-documents
   C) Next steps: GET /api/cases/:caseId/next-steps?docId=... returns typical options (no directives)
   D) Evidence-free default: documents.draft_mode defaults to EVIDENCE_FREE and evidence_free=true
   E) Add new templates (petition / answer) and force caption+disclaimer in export generator
   F) Put claims/citations behind an explicit toggle (advanced mode) instead of default

POST-IMPLEMENTATION HEALTH CHECK:
- Did it work?
- Did anything break?
- Did it work on civilla.ai?
- Did refresh/login persist?
- Did mobile behavior break?
OUT

# ------------------------------------------------------------------------------
# 9) Drop a runnable script placeholder so Replit has a consistent entry point
# ------------------------------------------------------------------------------
write "scripts/apply_case_stub_intake.sh" '
#!/usr/bin/env bash
set -euo pipefail
echo "This script was already applied. Re-run the original bootstrap command if you need to re-generate files."
'
chmod +x "scripts/apply_case_stub_intake.sh"

echo
echo "DONE."
