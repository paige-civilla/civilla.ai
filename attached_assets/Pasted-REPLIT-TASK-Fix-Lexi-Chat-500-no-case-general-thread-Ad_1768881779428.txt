REPLIT TASK: Fix Lexi Chat 500 (no-case/general thread) + Add true end-to-end functional audit script

Problem A — Lexi Chat fails unless a case exists
Current audit result: Lexi Chat returns HTTP 500 with note “needs case”.
Lexi MUST work in general threads (no active case) and case threads.

DO THIS FIX FIRST:
1) Locate the /api/lexi/chat handler in server/routes.ts.
2) Ensure it works when:
   - thread.caseId is null OR "__general__"
   - request body does not include caseId
3) Update prompt/context injection logic:
   - If caseId is missing OR "__general__", DO NOT call any case-scoped fetches.
   - Use a minimal “general context” block instead (user prefs only; no case memory, no case data).
4) Any function like getCase(), getCaseMemory(), listCaseClaims(), listTimelineEvents(), etc. must only run when caseId is a real UUID.
5) If a caseId is required for some specific feature, return a clean 400 with a clear message — but DO NOT 500.

Acceptance:
- POST /api/lexi/chat works with a general thread and returns a response.
- No DB foreign key errors and no “case not found” crashes.

Problem B — We still don’t have a real end-to-end audit
The current audit proves only basic auth endpoints. We need a functional audit that:
- creates a test case
- uploads evidence
- runs extraction
- runs AI analysis
- runs claims suggestion
- accepts claims + compiles document
- runs exports
- verifies DB rows/status transitions
- outputs a readable report

IMPLEMENT THIS:
1) Create script: script/fullFunctionalAudit.ts
   Requirements:
   - Uses TEST_EMAIL / TEST_PASSWORD from env
   - Logs in and persists cookie jar across requests
   - Creates a new test case (title “QA Functional Audit Case”)
   - Uploads TWO evidence files (one PDF, one image). If direct upload is hard:
     - use existing upload helpers or seed R2 + DB using the same service layer used by the app.
   - Triggers extraction and polls until complete/failed (with timeout).
   - Triggers AI analysis and polls until complete/failed.
   - Triggers claims suggest and verifies:
       case_claims created (>=3)
       claim_citations created (>=1 per claim ideally)
   - Accepts at least 2 claims.
   - Compiles from claims and verifies a document record exists.
   - Calls pattern-analysis export + trial-prep export endpoints and verifies ZIP responses.
   - Creates Lexi general thread, sends a message, verifies assistant message saved.
   - Validates returned sources:
       must be absolute https:// URLs
       optionally HEAD-check up to 3 sources; record non-200s

2) Outputs:
   - audit/functional_audit.json (structured results)
   - AUDIT_FUNCTIONAL_REPORT.md (human readable)
   Include PASS/FAIL per step + endpoint + error snippet.

3) Add npm script:
   - "audit:functional": "tsx script/fullFunctionalAudit.ts"

4) Update existing aiSmoke.ts to stop claiming coverage it doesn’t have:
   - It must clearly label “basic connectivity checks only”
   - It must not label Lexi chat as “needs case” unless that is confirmed post-fix

Acceptance:
- Running `npm run audit:functional` produces the two output files and:
  - PASS for Lexi chat with general thread
  - PASS or clear failures for extraction/analysis/claims/compile/exports with exact reasons

Deliverables to return in your reply:
- Files changed list
- Confirmation Lexi chat works without a case
- Summary table of functional audit results (PASS/FAIL)
- Any remaining failing steps with exact fix recommendations